# 2.4.2 Převody mezi RV a KA

<a id="algo-rv-to-ka"></a>
!!! Algorithm "[Regulární výraz → Konečný automat](#algo-rv-to-ka)"

    ### Regulární výraz → Konečný automat {#algo-rv-to-ka}

    Existují tři základní metody:

    1.  **Metoda sousedů:**
        *   Očíslujeme symboly v RV.
        *   Určíme množiny počátečních symbolů ($Z$), koncových symbolů ($F$) a sousedů ($P$).
        *   Sestrojíme automat, kde stavy odpovídají očíslovaným symbolům + počáteční stav $q_0$. Přechody konstruujeme na základě množin $Z$ a $P$.
        *   Výsledkem je obecně homogenní NKA (bez $\varepsilon$-přechodů).

    2.  **Metoda derivací:**
        *   Původní RV prohlásíme za počáteční stav.
        *   Derivujeme výrazy podle symbolů abecedy. Výsledky derivací (po úpravě/zjednodušení) tvoří nové stavy.
        *   Pokud $\varepsilon \in h(V)$, je stav $V$ koncový.
        *   Výsledkem je úplně určený DKA (nemusí být minimální).

    3.  **Metoda postupné konstrukce:**
        *   Sestavíme elementární automaty pro $\varepsilon, \emptyset, a$.
        *   Skládáme je pomocí operací sjednocení, zřetězení a iterace (viz skládání automatů).
        *   Výsledkem je NKA s $\varepsilon$-přechody.

<a id="algo-metoda-sousedu"></a>
!!! Algorithm "[Metoda sousedů (Glushkovova konstrukce)](#algo-metoda-sousedu)"

    ### Metoda sousedů {#algo-metoda-sousedu}

    Tato metoda vytváří nedeterministický konečný automat (zpravidla homogenní a bez $\varepsilon$-přechodů).

    1.  **Očíslování:** V zadaném regulárním výrazu $V$ očíslujeme každý výskyt symbolu z abecedy unikátním indexem (např. $a_1, b_2, a_3 \dots$). Tím získáme výraz $V'$.
    2.  **Identifikace množin:**
        *   **Množina počátečních symbolů ($Z$):** Symboly, kterými mohou začínat slova generovaná $V'$.
        *   **Množina koncových symbolů ($F$):** Symboly, kterými mohou končit slova generovaná $V'$.
        *   **Množina sousedů ($P$):** Dvojice symbolů $(x_i, y_j)$, které se ve slovech generovaných $V'$ mohou vyskytovat bezprostředně za sebou.
    3.  **Konstrukce automatu:**
        *   **Stavy:** Pro každý očíslovaný symbol $x_i$ vytvoříme stav. Navíc přidáme speciální počáteční stav $q_0$.
        *   **Přechody z $q_0$:** Pro každý symbol $x_i \in Z$ vedeme přechod $q_0 \xrightarrow{x} x_i$.
        *   **Vnitřní přechody:** Pro každou dvojici $(x_i, y_j) \in P$ vedeme přechod $x_i \xrightarrow{y} y_j$.
        *   **Koncové stavy:** Všechny stavy odpovídající symbolům z množiny $F$ jsou koncové.
        *   **Prázdné slovo:** Pokud $\varepsilon \in h(V)$, pak je i počáteční stav $q_0$ koncový.

<a id="algo-metoda-derivaci"></a>
!!! Algorithm "[Metoda derivací (Brzozowského derivace)](#algo-metoda-derivaci)"

    ### Metoda derivací {#algo-metoda-derivaci}

    Tato metoda vytváří deterministický konečný automat (přímo, bez mezikroku NKA).

    1.  **Počáteční stav:** Původní regulární výraz $V$ prohlásíme za počáteční stav automatu ($q_0 = V$).
    2.  **Iterační krok:** Pro každý stav (reprezentovaný výrazem $R$) a pro každý symbol abecedy $a \in \Sigma$ vypočítáme **derivaci** $\frac{dR}{da}$.
        *   Výsledný výraz po derivaci (a případném zjednodušení) představuje cílový stav přechodu.
        *   Pokud tento výraz (stav) v automatu ještě neexistuje, vytvoříme jej a zařadíme do fronty ke zpracování.
        *   Pokud již existuje (nebo existuje jemu *podobný/ekvivalentní* výraz), vedeme přechod do tohoto existujícího stavu.
    3.  **Opakování:** Postup opakujeme, dokud vznikají nové stavy.
    4.  **Koncové stavy:** Stavem je regulární výraz $R$. Tento stav je koncový právě tehdy, když $\varepsilon \in h(R)$ (tj. výraz je "nullable").

<a id="algo-postupna-konstrukce"></a>
!!! Algorithm "[Metoda postupné konstrukce (Thompsonova konstrukce)](#algo-postupna-konstrukce)"

    ### Metoda postupné konstrukce {#algo-postupna-konstrukce}

    Tato metoda staví automat strukturálně od nejjednodušších částí (induktivně). Výsledkem je NKA s $\varepsilon$-přechody.

    1.  **Elementární automaty:** Vytvoříme triviální automaty pro základní výrazy:
        *   Pro $\emptyset$ (prázdný jazyk).
        *   Pro $\varepsilon$ (prázdné slovo).
        *   Pro každý symbol $a \in \Sigma$.
        
        ![Thompsonova konstrukce - elementární automaty](../../assets/02/thompson1_white.png#only-dark)
        ![Thompsonova konstrukce - elementární automaty](../../assets/02/thompson1_black.png#only-light)

    2.  **Skládání:** Podle struktury výrazu spojujeme automaty pomocí operací:
        *   **Sjednocení ($R_1 + R_2$):** Vytvoříme nový počáteční a koncový stav a pomocí $\varepsilon$-přechodů "rozvětvíme" výpočet do automatů pro $R_1$ a $R_2$.
        *   **Zřetězení ($R_1 \cdot R_2$):** Koncový stav automatu pro $R_1$ propojíme $\varepsilon$-přechodem s počátečním stavem automatu pro $R_2$.
        *   **Iterace ($R^*$):** Zavedeme nový počáteční a koncový stav. Přidáme $\varepsilon$-přechody umožňující přeskočení celého automatu pro $R$ (pro $\varepsilon$) a návrat z konce na začátek (pro opakování).
    
        ![Thompsonova konstrukce - skládání](../../assets/02/thompson2_white.png#only-dark)
        ![Thompsonova konstrukce - skládání](../../assets/02/thompson2_black.png#only-light)

---

<a id="algo-ka-to-rv"></a>
!!! Algorithm "[Konečný automat → Regulární výraz](#algo-ka-to-rv)"

    ### Konečný automat → Regulární výraz {#algo-ka-to-rv}

    Existují tři základní metody:

    1.  **Metoda regulárních rovnic – odchozí přechody:**
        *   Sestavíme soustavu pravých regulárních rovnic ($A = aB + \dots$).
        *   Řešíme pro neznámou odpovídající počátečnímu stavu.

    2.  **Metoda regulárních rovnic – příchozí přechody:**
        *   Sestavíme soustavu levých regulárních rovnic.
        *   Řešíme pro neznámé odpovídající koncovým stavům a výsledky sjednotíme.

    3.  **Metoda eliminace stavů:**
        *   Upravíme automat tak, aby měl jeden počáteční a jeden koncový stav (pomocí $\varepsilon$-přechodů).
        *   Postupně eliminujeme stavy a nahrazujeme cesty regulárními výrazy na hranách.
        *   Výsledný výraz je na hraně mezi počátečním a koncovým stavem.

<a id="algo-rv-odchozi"></a>
!!! Algorithm "[Metoda regulárních rovnic – odchozí přechody](#algo-rv-odchozi)"

    ### Metoda regulárních rovnic – odchozí přechody {#algo-rv-odchozi}

    Tato metoda využívá soustavu pravých regulárních rovnic.

    1.  **Sestavení rovnic:** Stavy automatu prohlásíme za neznámé v soustavě rovnic. Pro každý stav $A$ sestavíme rovnici:

        $$A = \alpha_1 X_1 + \alpha_2 X_2 + \dots + \alpha_n X_n (+ \varepsilon)$$
    
        kde $A \xrightarrow{\alpha_i} X_i$ jsou všechny **odchozí přechody** ze stavu $A$.
    2.  **Koncové stavy:** Do rovnic pro všechny stavy, které jsou v automatu **koncové**, přidáme na pravou stranu člen $+\ \varepsilon$.

        ![Metoda regulárních rovnic – odchozí přechody](../../assets/02/odchozi_white.png#only-dark){ width="50%" }
        ![Metoda regulárních rovnic – odchozí přechody](../../assets/02/odchozi_black.png#only-light){ width="50%" }

    3.  **Řešení:** Soustavu rovnic vyřešíme (pomocí substituce a Ardenova lemmatu $X = \alpha X + \beta \Rightarrow X = \alpha^* \beta$).
    4.  **Výsledek:** Výsledný regulární výraz odpovídá řešení pro neznámou, která reprezentuje **počáteční stav** automatu.

<a id="algo-rv-prichozi"></a>
!!! Algorithm "[Metoda regulárních rovnic – příchozí přechody](#algo-rv-prichozi)"

    ### Metoda regulárních rovnic – příchozí přechody {#algo-rv-prichozi}

    Tato metoda využívá soustavu levých regulárních rovnic.

    1.  **Sestavení rovnic:** Stavy automatu prohlásíme za neznámé. Pro každý stav $A$ sestavíme rovnici:

        $$A = X_1 \alpha_1 + X_2 \alpha_2 + \dots + X_n \alpha_n (+ \varepsilon)$$
    
        kde $X_i \xrightarrow{\alpha_i} A$ jsou všechny **příchozí přechody** do stavu $A$.
    2.  **Počáteční stav:** Do rovnice pro neznámou reprezentující **počáteční stav** přidáme na pravou stranu člen $+\ \varepsilon$.

        ![Metoda regulárních rovnic – příchozí přechody](../../assets/02/prichozi_white.png#only-dark){ width="50%" }
        ![Metoda regulárních rovnic – příchozí přechody](../../assets/02/prichozi_black.png#only-light){ width="50%" }

    3.  **Řešení:** Soustavu vyřešíme (pro rovnici $X = X\alpha + \beta$ je řešením $X = \beta\alpha^*$).
    4.  **Výsledek:** Výsledný regulární výraz je **sjednocením** (součtem) řešení pro všechny neznámé, které odpovídají **koncovým stavům** automatu.

<a id="algo-eliminace-stavu-prepis"></a>
!!! Algorithm "[Metoda eliminace stavů](#algo-eliminace-stavu-prepis)"

    ### Metoda eliminace stavů {#algo-eliminace-stavu-prepis}

    1.  Nejprve přidáme **nový počáteční stav** $S'$ a u původního počátečního stavu $S$ tento příznak zrušíme. Poté přidáme $\varepsilon$-přechod z $S'$ do $S$. Pokud má automat **více koncových stavů**, přidáme **nový koncový stav** $F'$, u původních tento příznak zrušíme a ze všech původních koncových stavů přidáme $\varepsilon$-přechody do stavu $F'$. Pokud má automat pouze jeden koncový stav, pak jej pouze přejmenujeme na $F'$ a žádný nový koncový stav nepřidáváme.

        ![Normalizace automatu](../../assets/02/eliminace1_white.png#only-dark){ width="75%" }
        ![Normalizace automatu](../../assets/02/eliminace1_black.png#only-light){ width="75%" }

    2.  Dále v libovolném pořadí **eliminujeme jednotlivé stavy** automatu (kromě stavů $S'$ a $F'$). Při eliminaci nějakého stavu $q$ postupujeme tak, že každou cestu délky dva vedoucí přes stav $q$ (tj. příchozí přechod do $q$ a odchozí přechod z $q$) nahradíme po vynechání stavu $q$ jedním přechodem, jenž označíme **zřetězením** příslušných RV. Případnou **smyčku** nahradíme **iterací**.

        ![Eliminace stavů](../../assets/02/eliminace2_white.png#only-dark){ width="50%" }
        ![Eliminace stavů](../../assets/02/eliminace2_black.png#only-light){ width="50%" }

    3.  Pokud má eliminovaný stav více příchozích (odchozích) přechodů, pak každý příchozí přechod kombinujeme se všemi odchozími, abychom pokryli všechny cesty délky dva procházející eliminovaným stavem. Během eliminace nahrazujeme **souběžné přechody sjednocením** příslušných RV:

        ![Sjednocení přechodů](../../assets/02/eliminace3_white.png#only-dark){ width="50%" }
        ![Sjednocení přechodů](../../assets/02/eliminace3_black.png#only-light){ width="50%" }

    **Výsledný regulární výraz** je ten, který vznikne po eliminaci všech původních stavů automatu na přechodu mezi stavy $S'$ a $F'$.