# 2.2.7 Skládání konečných automatů

Skládání automatů nám umožňuje konstruovat automaty pro složitější jazyky pomocí jednodušších automatů a operací nad jazyky.

### Operace a konstrukce

<a id="op-sjednoceni"></a>
!!! Algorithm "Sjednocení"

    ### Sjednocení {#op-sjednoceni}

    Pro dva KA $M_1$ a $M_2$ zkonstruujeme KA přijímající sjednocení jazyků $L(M_1) \cup L(M_2)$ následovně:

    *   **pomocí $\varepsilon$-přechodů:** Vytvoříme nový počáteční stav a $\varepsilon$-přechody do původních počátečních stavů (vstupní $M_1$ a $M_2$ jsou NKA, NKA s $\varepsilon$-přechody nebo DKA).
    *   **jako NKA s více počátečními stavy:** Sjednotíme množiny počátečních stavů (vstupní $M_1$ a $M_2$ jsou NKA, NKA s $\varepsilon$-přechody nebo DKA).
    *   **pomocí paralelní činnosti:** Vstupní $M_1$ a $M_2$ musí být **úplně určené** DKA nebo úplně určené NKA. Stavy výsledného automatu jsou dvojice $(q_1, q_2)$, kde $q_1$ je stav z $M_1$ a $q_2$ z $M_2$. Koncové stavy jsou ty, které obsahují koncový stav alespoň jednoho ze vstupních automatů.

<a id="op-prunik"></a>
!!! Algorithm "Průnik"

    ### Průnik {#op-prunik}

    Pro dva KA $M_1$ a $M_2$ zkonstruujeme KA přijímající průnik jazyků $L(M_1) \cap L(M_2)$ pomocí **paralelní činnosti**.

    *   Vstupní $M_1$ a $M_2$ jsou NKA (bez $\varepsilon$-přechodů a s jedním počátečním stavem) či DKA, **nemusí být úplně určené**.
    *   Koncové stavy výsledného automatu jsou ty dvojice, které obsahují koncový stav z **obou** vstupních automatů zároveň.

<a id="algo-paralelni-cinnost"></a>
!!! Algorithm "Konstrukce pomocí paralelní činnosti"

    ### Paralelní činnost (Produktová konstrukce) {#algo-paralelni-cinnost}

    Tento algoritmus se používá pro **sjednocení** a **průnik**. Předpokládáme dva automaty $M_1 = (Q_1, \Sigma, \delta_1, q_{01}, F_1)$ a $M_2 = (Q_2, \Sigma, \delta_2, q_{02}, F_2)$, které jsou **úplně určené** (DKA nebo NKA). Výsledný automat $M = (Q, \Sigma, \delta, q_0, F)$ pracuje následovně:

    1.  **Stavy ($Q$):** Stavy jsou uspořádané dvojice ze součinu množin stavů původních automatů.
        $Q = Q_1 \times Q_2$
    2.  **Počáteční stav ($q_0$):** Dvojice tvořená počátečními stavy obou automatů.
        $q_0 = (q_{01}, q_{02})$
    3.  **Přechodová funkce ($\delta$):** Přechody jsou definovány po složkách. Automat simuluje oba automaty zároveň. Pro $p \in Q_1, q \in Q_2, a \in \Sigma$:
        $\delta((p, q), a) = (\delta_1(p, a), \delta_2(q, a))$
    4.  **Koncové stavy ($F$):** Liší se podle operace:
        *   **Pro sjednocení ($L_1 \cup L_2$):** Alespoň jeden stav ve dvojici musí být koncový.
            $F = (F_1 \times Q_2) \cup (Q_1 \times F_2)$
        *   **Pro průnik ($L_1 \cap L_2$):** Oba stavy ve dvojici musí být koncové.
            $F = F_1 \times F_2$
    
    ![Paralelní činnost](../../assets/02/paralelni_cinnost_priklad_white.png#only-dark){ align=center }
    ![Paralelní činnost](../../assets/02/paralelni_cinnost_priklad_black.png#only-light){ align=center }

<a id="op-doplnek"></a>
!!! Algorithm "Doplněk jazyka"

    ### Doplněk jazyka {#op-doplnek}

    Pro KA $M_1$ zkonstruujeme KA přijímající doplněk jazyka $\overline{L(M_1)}$ pomocí **prohození koncových a nekoncových stavů**.

    *   **Podmínka:** Vstupní automat $M_1$ musí být **úplně určený DKA**.

<a id="op-rozdil"></a>
!!! Algorithm "Rozdíl"

    ### Rozdíl {#op-rozdil}

    Pro dva KA $M_1$ a $M_2$ zkonstruujeme KA přijímající rozdíl jazyků $L(M_1) \setminus L(M_2)$ s využitím vztahu:
    
    $$L(M_1) \setminus L(M_2) = L(M_1) \cap \overline{L(M_2)}$$

<a id="op-soucin"></a>
!!! Algorithm "Součin (zřetězení)"

    ### Součin (zřetězení) {#op-soucin}

    Pro dva KA $M_1$ a $M_2$ zkonstruujeme KA přijímající součin jazyků $L(M_1) \cdot L(M_2)$ pomocí **$\varepsilon$-přechodů**.

    *   Ze všech koncových stavů automatu $M_1$ vedeme $\varepsilon$-přechody do počátečního stavu automatu $M_2$.
    *   Koncové stavy automatu $M_1$ přestanou být koncové (pokud $\varepsilon \notin L(M_2)$).
    *   Vstupní $M_1$ a $M_2$ jsou NKA, NKA s $\varepsilon$-přechody nebo DKA, nemusí být úplně určené.

<a id="op-iterace"></a>
!!! Algorithm "Iterace"

    ### Iterace {#op-iterace}

    Pro KA $M_1$ zkonstruujeme KA přijímající iteraci jazyka $L(M_1)^*$ zavedením nového počátečního stavu a $\varepsilon$-přechodů.

    *   Přidáme nový počáteční stav, který je zároveň koncový (pro přijetí $\varepsilon$).
    *   Z nového počátečního stavu vedeme $\varepsilon$-přechod do původního počátečního stavu.
    *   Ze všech původních koncových stavů vedeme $\varepsilon$-přechody zpět do původního počátečního stavu.
    *   Vstupní $M_1$ je NKA, NKA s $\varepsilon$-přechody nebo DKA, nemusí být úplně určený.

!!! Warning "Důležitost nového počátečního stavu u iterace"
    U iterace je nutné přidat **nový** počáteční stav. Nelze pouze prohlásit původní počáteční stav za koncový, protože by to mohlo změnit jazyk nesprávným způsobem (např. přijetím slov, která v iteraci být nemají, pokud se do počátečního stavu vrací nějaký cyklus).

### Algoritmy pro rozhodování vlastností

<a id="algo-decision-full"></a>
!!! Algorithm "Rozhodnutí, zdali L(M) = Σ*"

    ### Rozhodnutí, zdali $L(M) = \Sigma^*$ {#algo-decision-full}

    1. Pro automat $M$ vytvoříme ekvivalentní **deterministický minimální automat** $M'$.
    2. Pokud má automat $M'$ pouze jeden stav, který je zároveň počáteční a koncový se smyčkou pro všechny symboly $a \in \Sigma$, poté $L(M) = \Sigma^*$, jinak $L(M) \neq \Sigma^*$.

<a id="algo-decision-empty"></a>
!!! Algorithm "Rozhodnutí, zdali L(M) = ∅"

    ### Rozhodnutí, zdali $L(M) = \emptyset$ {#algo-decision-empty}

    1. Pro automat $M$ vytvoříme ekvivalentní automat $M'$ bez **nedosažitelných stavů**.
    2. Pokud v automatu $M'$ neexistují žádné koncové stavy, poté $L(M) = \emptyset$, jinak $L(M) \neq \emptyset$.

<a id="algo-decision-eq"></a>
!!! Algorithm "Rozhodnutí, zdali L(M1) = L(M2)"

    ### Rozhodnutí, zdali $L(M_1) = L(M_2)$ {#algo-decision-eq}

    1. Pro automat $M_1$ vytvoříme ekvivalentní deterministický minimální automat $M'_1$.
    2. Pro automat $M_2$ vytvoříme ekvivalentní deterministický minimální automat $M'_2$.
    3. Pokud mezi automaty $M'_1$ a $M'_2$ existuje **izomorfismus**, poté $L(M_1) = L(M_2)$, jinak $L(M_1) \neq L(M_2)$.

<a id="algo-decision-subset"></a>
!!! Algorithm "Rozhodnutí, zdali L(M1) ⊆ L(M2)"

    ### Rozhodnutí, zdali $L(M_1) \subseteq L(M_2)$ {#algo-decision-subset}

    Využijeme vztahu $L(M_1) \subseteq L(M_2) \iff L(M_1) \setminus L(M_2) = \emptyset$.

    1. Vytvoříme automat $M_3$ přijímající jazyk $L(M_3) = L(M_1) \cap \overline{L(M_2)}$.
    2. Rozhodneme, zda $L(M_3) = \emptyset$ (viz algoritmus výše).
    3. Pokud $L(M_3) = \emptyset$, pak platí $L(M_1) \subseteq L(M_2)$.